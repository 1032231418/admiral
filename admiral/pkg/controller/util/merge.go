package util

import (
	"fmt"
	proto "github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/types"
	v1 "github.com/istio-ecosystem/admiral/admiral/pkg/apis/admiral/v1"
	networkingv1alpha3 "istio.io/api/networking/v1alpha3"
	"istio.io/client-go/pkg/apis/networking/v1alpha3"
	"sort"
	"strings"
)

const defaultRoute = "default"

func Merge(sc *v1.ServiceClient, vs *v1alpha3.VirtualService, dr *v1alpha3.DestinationRule, sourceLabelKeys []string) (*v1alpha3.VirtualService, *v1alpha3.DestinationRule, error) {

	vs = vs.DeepCopy()
	dr = dr.DeepCopy()

	source, err := buildSourceLabels(sc, sourceLabelKeys)
	if err != nil {
		return nil, nil, err
	}

	vsMatchGenMap, vsMatchMap := buildMatchMaps(vs, source)

	for _, http := range sc.Spec.Http {

		key, gen := buildMatchKey(http.Match, source)

		if gen {
			//this is a service client for the source labels should be blank make gen always false
			return nil, nil, fmt.Errorf("ServiceClient can't have source lables in the match")
		}

		route, gen := vsMatchGenMap[key]
		if !gen {
			route2, ok := vsMatchMap[key]
			if !ok {
				if http.Match == nil {
					route, _ = vsMatchMap[defaultRoute]
				}
			} else {
				route = route2
			}
		}

		if route != nil {
			//exiting route clone it
			route = proto.Clone(route).(*networkingv1alpha3.HTTPRoute)
		} else {
			//exiting match didn't match mint a new route
			route = &networkingv1alpha3.HTTPRoute{}
			//route was null so no match was found so create a new match
			if http.Match != nil {
				route.Match = make([]*networkingv1alpha3.HTTPMatchRequest, 0)
				for _, m := range http.Match {
					route.Match = append(route.Match, proto.Clone(m).(*networkingv1alpha3.HTTPMatchRequest))
				}

			}

			defaultRoute, ok := vsMatchMap[defaultRoute]
			if ok {
				if defaultRoute.Route != nil {
					route.Route = make([]*networkingv1alpha3.HTTPRouteDestination, 0)
					for _, r := range defaultRoute.Route {
						route.Route = append(route.Route, proto.Clone(r).(*networkingv1alpha3.HTTPRouteDestination))
					}
				}
			}

		}

		if http.Timeout != nil {
			route.Timeout = &types.Duration{}
			route.Timeout.Unmarshal([]byte(http.Timeout.String()))
		}

		if http.Fault != nil {
			route.Fault = proto.Clone(http.Fault).(*networkingv1alpha3.HTTPFaultInjection)
		}

		if http.Retries != nil {
			route.Retries = proto.Clone(http.Retries).(*networkingv1alpha3.HTTPRetry)
		}
		if !gen {
			//create settings
			//add source labels to match
			for _, m := range route.Match {
				m.SourceLabels = make(map[string]string)
				for key, value := range source {
					m.SourceLabels[key] = value
				}
			}
			vs.Spec.Http = append(vs.Spec.Http, route)
		}
	}

	//TODO source label generated first
	//TODO make sure to add routes back in order for non generated
	return vs, dr, nil
}

//first return map was flagged as generated seconds was not
func buildMatchMaps(vs *v1alpha3.VirtualService, source map[string]string) (map[string]*networkingv1alpha3.HTTPRoute, map[string]*networkingv1alpha3.HTTPRoute) {
	//map used to look up exiting matches that have not been generated
	vsMatchMap := make(map[string]*networkingv1alpha3.HTTPRoute, len(vs.Spec.Http))

	//map used to look up exiting matches that have been generated
	//if the source label match is equal to this client service
	//it will be considered generated by the is client service
	vsMatchGenMap := make(map[string]*networkingv1alpha3.HTTPRoute, len(vs.Spec.Http))

	for _, http := range vs.Spec.Http {
		if http.Match != nil {
			compositeKey, gen := buildMatchKey(http.Match, source)
			if gen {
				vsMatchGenMap[compositeKey] = http
			} else {
				vsMatchMap[compositeKey] = http
			}
		} else {
			vsMatchMap[defaultRoute] = http
		}
	}

	return vsMatchGenMap, vsMatchMap
}

func buildSourceLabels(sc *v1.ServiceClient, sourceLabelKeys []string) (map[string]string, error) {
	source := make(map[string]string, len(sourceLabelKeys))

	//pre source label match
	for _, key := range sourceLabelKeys {
		value, ok := sc.Labels[key]
		if !ok {
			return nil, fmt.Errorf("failed to match lables sourcekeys: %v    service client map: %v", sourceLabelKeys, sc.Labels)
		}
		source[key] = value
	}
	return source, nil
}

func buildMatchKey(match []*networkingv1alpha3.HTTPMatchRequest, sourceLabels map[string]string) (string, bool) {

	gen := false
	keys := make([]string, len(match))
	for _, match := range match {

		gen = testGenSourceLabels(match, sourceLabels, gen)
		keys = append(keys, match.String())
	}

	sort.Strings(keys)
	compositKey := strings.Join(keys, "-")
	return compositKey, gen
}

func testGenSourceLabels(match *networkingv1alpha3.HTTPMatchRequest, sourceLabels map[string]string, gen bool) bool {
	if match.SourceLabels != nil {
		test := true

		//if the labels don't match return gen false
		for key, value := range match.SourceLabels {

			v, ok := sourceLabels[key]
			if ok {
				if v != value {
					test = false
				}
			} else {
				test = false
			}
		}
		gen = test
	}
	return gen
}
